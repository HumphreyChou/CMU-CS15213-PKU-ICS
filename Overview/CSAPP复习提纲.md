# <center>CS:APP 复习提纲</center> {ignore=true}

## <center>联系作者</center> {ignore=true}

zhouyuhan_@outlook.com
humpreychou@gmail.com

## <center>目录</center> {ignore=true}

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [第一章 计算机系统漫游](#center第一章-计算机系统漫游center)
- [第二章 信息的表示和处理](#center第二章-信息的表示和处理center)
  - [1. 信息存储](#1-信息存储)
  - [2. 整数表示](#2-整数表示)
    - [1. 编码](#1-编码)
    - [2. 转换](#2-转换)
    - [3. 截断与扩展](#3-截断与扩展)
    - [4. 整数运算](#4-整数运算)
  - [3. 浮点数](#3-浮点数)
    - [1. IEEE 浮点表示](#1-ieee-浮点表示)
    - [2. 浮点运算](#2-浮点运算)
    - [3. C 语言浮点运算](#3-c-语言浮点运算)
- [第三章 程序的机器级表示](#center第三章-程序的机器级表示center)
  - [1. 数据格式](#1-数据格式)
  - [2. 非控制指令](#2-非控制指令)
  - [3. 控制指令](#3-控制指令)
  - [4. 条件](#4-条件)
  - [5. 循环](#5-循环)
  - [6. 过程](#6-过程)
  - [7. 数组](#7-数组)
  - [8. 对齐](#8-对齐)
  - [9. 缓冲区溢出](#9-缓冲区溢出)
  - [10. 浮点代码](#10-浮点代码)
- [第四章 处理器体系结构](#center第四章-处理器体系结构center)
  - [1. Y86-64 指令集体系结构](#1-y86-64-指令集体系结构)
  - [2. 硬件](#2-硬件)
  - [3. Y86-64 顺序实现](#3-y86-64-顺序实现)
  - [4. Y86-64 流水线实现](#4-y86-64-流水线实现)
  - [5. 性能分析](#5-性能分析)
- [第五章 优化程序性能](#center第五章-优化程序性能center)
  - [1. 编译器自动优化](#1-编译器自动优化)
  - [2. 性能表示](#2-性能表示)
  - [3. 提高程序性能方法](#3-提高程序性能方法)
- [第六章 存储器层次结构](#center第六章-存储器层次结构center)
  - [1. 存储技术](#1-存储技术)
  - [2. 局部性](#2-局部性)
  - [3. 存储器层次结构](#3-存储器层次结构)
  - [4. 高速缓存存储器（cache）](#4-高速缓存存储器cache)
- [第七章 链接 ](#center第七章-链接-center)
  - [1. C 程序驱动](#1-c-程序驱动)
  - [2. 静态链接](#2-静态链接)
- [附录：推荐阅读](#附录推荐阅读)

<!-- /code_chunk_output -->

## <center>第一章 计算机系统漫游</center>

1. C 程序的执行
   预处理-编译-汇编-链接-执行
   @import "1-3.jpg"
2. 进程，线程

- 进程：操作系统对正在运行的程序的抽象
  - 上下文切换
  - 操作系统内核控制
- 线程：一个进程由多个线程组成，每个线程共享代码和全局数据

3. Amdahl 定律
   优化部分时间占比 $\alpha$, 优化部分提升比例 $k$, 则加速比：
   $$ S = T_{old}/T_{new} = \frac{1}{1 - \alpha + \alpha / k} $$

## <center>第二章 信息的表示和处理</center>

### 1. 信息存储

1. 小端法，大端法

- 大端法：IBM Oracle（Sun）
- 小端法：Intel Android iOS

2. C 语言移位运算

- 左移：丢弃高位，低位补 0
- 右移：
  - 逻辑右移：丢弃低位，高位补 0 —— 无符号数
  - 算数右移：丢弃地位，高位补最高位的值 —— 有符号数

### 2. 整数表示

@import "2-10.jpg"

#### 1. 编码

- 无符号编码$B2U_w(x)$、有符号编码$B2T_w(x)$都是双射
- $|TMin| = |TMax| + 1$
- $UMax_w = 2TMax_w + 1$

#### 2. 转换

1. 有符号-无符号：位级表示不变，改变解释方式
   @import "2.5.jpg"
2. 无符号-有符号：最高位为 1 则解释为负数
   @import "2.7.jpg"
3. C 语言有符号、无符号数混合运算——隐式转换为无符号数
   `unsigned a, int b`
   `a < b --> a < (unsigned)b`

#### 3. 截断与扩展

1. 截断
   截断$x$到$k$位得到$x'$

- 无符号：$x' = x \, mod \, 2^k$
- 有符号：$x' = U2T_k(x \, mod \, 2^k)$

2. 扩展
   保持位扩展后数值不变

- 无符号：零扩展
- 有符号：符号扩展

#### 4. 整数运算

1. 无符号加法：截断溢出位——模数加法 $x + ^u_w y = (x + y) \, mod \, 2^w$
   @import "2.11.jpg"
   溢出检测：`s == x + y && (s < x || s < y)`
2. 无符号取负
   @import "2.12.jpg"

3. 有符号加法：溢出——变号
   @import "2.13.jpg"
   溢出检测：`s == x + y && ((x > 0 && y > 0 && s <= 0) || (x < 0 && y < 0 && s >= 0)) `
4. 有符号取负： `-x == ~x + 1`
   @import "2.15.jpg"

5. 乘法：无符号、有符号乘法位级表示相同

- 无符号乘法：模数乘法 $x * ^u_w y = (x \cdot y) \, mod \, 2^w$
- 有符号乘法：进行无符号乘法后转换为有符号数 $x * ^t_w y = U2T_w((x \cdot y) \, mod \, 2^w)$
- 乘以常数：编译器进行优化，改为乘以 2 的幂之和
  @import "2.0.jpg"

6. 除法：只讨论除以 2 的幂的简单情形
   $x >> k = \lfloor x/2^k \rfloor$, $\quad (x + (1 << k) - 1) >> k = \lceil x / 2^k \rceil$
   整数除法要求向零取整，因此`x / pow(2, k) == (x < 0 ? x + (1 << k) - 1 : x) >> k`

==整数加法、乘法满足交换律、结合律，无单调性==

### 3. 浮点数

#### 1. IEEE 浮点表示

1. 表示方法
   $V = (-1)^s \times M \times 2^E $
   @import "2.32.jpg"
   单精度：$s = 1, k = 8, n = 23$
   双精度：$s = 1, k = 11, n = 52$

- 规格化：$Bias = 2^{k - 1} - 1 \quad E = e - Bias \quad M = 1 + f$
- 非规格化：$E = 1 - Bias \quad M = f$
- 特殊值：$\infin \quad -\infin \quad NaN$

2. 表示好处

- 随位级表示增大，浮点数值单调增大（`01111 --> 10000`除外）
- 最大非规格化数到最小规格化数平滑转变

3. 舍入

- 数值不在最低精度相邻两个值中间：就近舍入
- 数值处在最低精度相邻两个值中间：向偶舍入 $XX\cdots X.YY\cdots Y100$

#### 2. 浮点运算

1. 加法：$x +^f y = Round(x + y)$

- ==浮点加法可交换，不可结合（舍入、溢出问题）==
- 浮点加法满足单调性

2. 乘法：$x *^f y = Round(x \times y)$

- ==浮点乘法可交换，不可结合==
- 浮点乘法对加法不可分配
- 浮点乘法满足单调性
- $a \ne NaN \Rightarrow a *^f a \ge 0$
- $inf == inf$
- $NaN \ne NaN$
- $-inf + inf \ne 0$

#### 3. C 语言浮点运算

`expr2 = expr1`
|`expr1`|`expr2`|溢出|舍入|
|:--:|:--:|:--:|:--:|
| `int` | `float` | 0 | 1 |
|`int`/`float` |`double` |0 |0 |
|`double` |`float` |1| 1|
| `float`/`double`| `int`| 1| 1|
注：`float / double --> int`溢出时，Intel 微处理器产生 $TMin$

## <center>第三章 程序的机器级表示</center>

### 1. 数据格式

1. 字长
   @import "3.1.jpg"
2. 整数寄存器
   `%rip`(Programme Counter), `%rsp`(Stack Pointer)
   @import "3.2.jpg"
   注：==以 32 位寄存器作为目标的操作会将高 32 位清零==
3. 操作数

- 立即数：`$0x0`
- 寄存器：$R[r_a]$
- 内存引用：$M_b[addr]$, 通用格式 $Imm(r_b, r_i, s) = Imm + R[r_b] + R[r_i] \cdot s \quad $ x86 体系内存引用寄存器必须为 64 位寄存器

### 2. 非控制指令

1. MOV
   @import "3.4.jpg"

特殊指令：

- `movabsq`传送 64 位立即数，必须以寄存器为目标。其他指令只能传送 32 位立即数
- `cltq`: `%rax <-- %eax`（符号扩展）

注：==传送指令涉及既改变数据大小又改变 C 语言中符号时，先改变大小==
e.g.

```
void func(unsigned char* src, long* dst) {
   *dst = *src
}
movzbq (%rdi), %rax
movq %rax, (%rsi)
```

2. PUSH POP
   栈向下生长，`%rsp`存储栈顶地址
   @import "3.8.jpg"
3. 算数、逻辑操作
   @import "3.10.jpg"
   特殊指令

- `leaq`: 往往不用来加载地址，而是灵活计算寄存器的值
- 移位指令位移量不用立即数表示时，只能存在`%cl`中，且对$w$位数据进行移位，位移量由`%cl`中低 $log_2w$ 位决定
- 乘除法特殊指令
  @import "3.12.jpg"

### 3. 控制指令

1. 条件码
   `t = a + b`
   @import "3.0.jpg"
2. CMP & TEST
   仅设置条件码
   @import "3.13.jpg"
3. SET
   根据条件码设置一个字节的值
   @import "3.14.jpg"
4. JMP

- 直接跳转 `jmp .L1`
- 间接跳转 `jmp *%rax jmp *(%rax)`, 不能使用条件跳转
  @import "3.15.jpg"
  注：跳转指令编码——PC 相对（PC-relative）

### 4. 条件

1. 条件分支

- 条件控制：`if else --> if goto`
- 条件传送：`x = condition ? expr1 : expr2` 支持 16、32、64 位条件传送，不支持单字节条件传送

### 5. 循环

1. `do while`：翻译为`if goto`
   @import "3.00.jpg"
2. `while`

- jump to middle:
  @import "3.01.jpg"
- guarded-do:
  @import "3.02.jpg"

3. `for`: 翻译为`while`
   @import "3.03.jpg"
4. `swith`: 跳转表

### 6. 过程

1. 栈帧
   @import "3.25.jpg"
2. 参数传送

- 前 6 个整数：寄存器
  @import "3.28.jpg"
- 7 个以上：在栈中从低到高放置，向 8 对齐

3. 返回值：`%rax`
4. 保存寄存器

- 被调用者保存：`%rbx, %rbp, %r12 - %r15`，保存方式：
  - 函数中从不修改被调用者保存寄存器的值
  - 函数起始将被调用者保存寄存器值压栈，函数结束弹栈
- 调用者保存：除`%rsp, %rip`其他

### 7. 数组

1. 嵌套数组寻址
   @import "3.04.jpg"
2. 变长数组：ISO C99 标准允许数组维度为表达式 `int array[n]`

### 8. 对齐

1. 对齐原则

- 基本对象：任何 K 子节基本对象地址必须是 K 的倍数
- 数组、结构体、联合：==Largest alignment of any element==, 不是按照所有元素的最大大小对齐

### 9. 缓冲区溢出

1. 缓冲区溢出攻击：

- 简单方法：直接通过读取操作的缓冲区溢出改写栈
- ROP(Return-Oriented Programming) 攻击：通过缓冲区写入多个库函数字节序列的末尾部分，利用`ret`指令实现跳转，构成完整恶意程序

2. 对抗方法

- 系统级：
  - 栈随机化：程序开始时在栈上随机分配一定字节的空间
  - 限制可执行代码区域：栈被标记为可读可写但不可执行
- 编译器级：
  - 栈破换检测：在缓冲区与栈状态之间插入“金丝雀值”(canary)

### 10. 浮点代码

1. AVX 浮点体系结构：

- 16 个 256 位（32 字节）YMM 寄存器
- 16 个 128 位（16 字节）XMM 寄存器
  @import "3.45.jpg"

2. 浮点传送与转换
- 传送：`vmov`
   @import "3.46.jpg"
- 浮点/整数转换：`vcvt`
   @import "3.47.jpg"
   @import "3.48.jpg"
- 单精度$\rightarrow $双精度：
   @import "3.05.jpg"
- 双精度$\rightarrow$单精度
   @import "3.06.jpg"

3. 浮点过程控制
- 函数参数由`%xmm0`-`%xmm7`8个寄存器传递
- `%xmm0`保存返回值
- 所有XMM 寄存器都是调用者保存

4. 浮点运算
三个操作数：$OP \, S_1 \, S_2 \, D$
@import "3.49.jpg"
@import "3.50.jpg"

5. 浮点比较
@import "3.07.jpg"
注：任一操作数为$NaN$时，奇偶校验位`PF`置为1

## <center>第四章 处理器体系结构</center>

### 1. Y86-64 指令集体系结构

1. Y86-64 程序员可见状态
   @import "4.1.jpg"
   `Stat: AOK HLT ADR INS`
1. Y86-64 指令
   10 字节编码
   @import "4.2.jpg"

- V 常数编码使用小端法
- 每个字节编码有唯一解释
- `rrmovq`与`cmov`指令字节高 4 位相同且为 2

3. RISC & CISC

|                          |   CISC    |             RISC              |
| :----------------------: | :-------: | :---------------------------: |
|           代表           | Intel AMD |          ARM RISC-V  MIPS         |
|         指令数量         |    多     |              少               |
|         指令延迟         | 有些很长  |         没有较长延迟          |
|         编码长度         |   可变    |             固定              |
|         寻址方式         |   多样    |             单一              |
|      算数、逻辑运算      | 可对内存  | 只对寄存器（load/store 体系） |
| 对于机器级程序的实现细节 |  不可见   |             可见              |
|          条件码          |    有     |              无               |
|         过程链接         |  栈密集   |          寄存器密集           |

### 2. 硬件

1. 电路、时钟

- 时序电路（sequential circuit）：存储状态，在时钟上跳沿改变数据
  - 寄存器
  - 随机访问存储器（RAM）
- 组合电路（combinational circuit）：由逻辑门（与门、或门、非门）构建计算块，不存储数据。可用 HCL 语言描述

### 3. Y86-64 顺序实现

SEQ：取指-译码-执行-访存-写回-更新 PC
所有阶段在一个时钟周期内完成，时钟频率低
@import "4.23.jpg"

### 4. Y86-64 流水线实现

1. 流水线原理

- 时钟周期 $T = max\{latency_{logic}\} + latency_{register}$
- 平均每一个时钟周期处理一条指令，则吞吐量 $Throughput = \frac{1}{T}$, 单位转换为 GIPS (Giga Instructions Per Second)

2. SEQ+ 实现：更新 PC 移至时钟周期开始时进行，无时钟寄存器存储 PC，而在程序运行中实时计算 PC
3. PIPE 实现
   @import "4.52.jpg"
   特点：

- Select A 模块：仅有`call` `jXX`指令在访存、执行阶段需要`valP`, 且不需要`valA`，因而合并二者
- 流水线冒险
  - 寄存器数据冒险：指令 Ins 从源 S 向寄存器 r 写值，后续指令在 Ins 写回阶段完成前使用 r 的值
    - S 是立即数或寄存器：数据转发（data forwarding）
    - S 是内存（加载、使用数据冒险）：加载互锁+数据转发（暂停一周期，插入一个气泡）
    - 数据转发优先级：
      @import "4.00.jpg"
  - 控制冒险：
    - `ret`：暂停三周期，插入三个气泡
    - 分支错误预测：插入两个气泡
      @import "4.66.jpg"
  - 组合：
    - A:`ret`+ 分支预测错误
    - B:`ret`+ 加载/使用数据冒险
- 异常处理：发生异常，标记禁止更新程序员不可见状态（CC、内存），异常状态随流水线传播，到达写回阶段中止程序
- 流水线控制逻辑
  @import "4.64.jpg"

### 5. 性能分析

衡量标准：CPI（Cycles Per Instruction）,吞吐量的倒数
$$CPI = 1.0 + \frac{C_b}{C_i}  = 1.0 + lp + mp + rp$$

## <center>第五章 优化程序性能</center>

### 1. 编译器自动优化

GCC: `gcc -Og -O1 -O2 -O3`
内存别名使用、有副作用的函数调用可能不会被优化

### 2. 性能表示

CPE（Cycles Per Element）:处理每个元素平均花费时钟周期数

### 3. 提高程序性能方法

1. 简单方法

- 代码移动：将计算多次的不变量移动至别处使之只计算一次
- 减少过程调用
- 消除不必要内存引用

2. 利用现代处理器方法
   现代处理器可以并行计算多条指令，只要指令间没有数据依赖

- 相关术语：

  - 延迟界限：操作必须严格按顺序执行时的性能界限
  - 吞吐量界限：处理器计算能力物理限制，程序的最终性能界限
  - 某个运算操作最大吞吐量：$n = \frac{C}{I}$，$C$为运算单元容量，$I$为发射数
  - 吞吐量界限 = $\frac{1}n $

- 循环展开：
  - 循环寄存器：循环中既作为源值又作为目的的寄存器，一次迭代的值会在另一次迭代中用到
  - 循环关键路径（critical path）: 循环寄存器构成的操作链
  - 循环展开方法：减少循环迭代次数，使用多个循环寄存器并行计算，使得关键路径缩短。$k \times k$循环展开可以使得关键路径缩短到$\frac1k$
  - 对于延迟为$L$，容量为$C$的操作，$k \ge C \cdot L $可以达到该操作吞吐量界限
  - 重新结合变换：代码先计算循环寄存器之外的数值，处理器可以实现其与循环寄存器并行计算
    `(acc OP a[i]) OP a[i + 1] --> acc OP (a[i] OP a[i + 1])`
- 书写适合用条件传送实现的代码

```c
if(condition)
    x = a         ---->   x = condition ? a : b
else
    x = b
```

- 避免读写相关：避免一个内存读的结果依赖于一个最近的内存写

## <center>第六章 存储器层次结构</center>

### 1. 存储技术

1. RAM(Random-Access Momery)： SRAM & DRAM
   @import "6.2.jpg"
2. 磁盘

- 机械硬盘：
  @import "6.9.jpg"
  @import "6.00.jpg"
- 固态硬盘（SSD）：基于 flush 存储技术

3. I/O 设备
   @import "6.11.jpg"

### 2. 局部性

1. 空间局部性：程序引用一个位置内存一次，不远的将来会引用附近位置内存
2. 时间局部性：被引用过一次的内存在不远的将来被多次引用
3. 循环步长越小，空间局部性越好；循环体越小、迭代次数越多，时间局部性越好

### 3. 存储器层次结构

@import "6.21.jpg"

1. 基本思想：第$k$层存储器作为第$k + 1$层存储器的缓存
2. 缓存命中：直接读取
3. 缓存不命中：

- 冷不命中：存储暖身
- 冲突不命中：取决于放置策略
- 容量不命中：工作集大于缓存本身

### 4. 高速缓存存储器（cache）

1. 通用结构
   @import "6.25.jpg"
   高速缓存结构使用$(S, E, B, m)$描述 内存地址使用$(t, s, b)$共$m$位表示

2. 例子

- 直接映射高速缓存 $E = 1$
- 组相联高速缓存 $1 < E < C/B$
- 全相联高速缓存 $E = C/B$

3. 组（Set）计算
   $$组编号 = 地址编号 / B \, mod \, S $$

4. 写内存

- 命中
  - 直写：直接写到下一层缓存
  - 写回：推迟更新直到该块需要被替换，再写道下一层缓存
- 不命中
  - 写分配：加载下一层块到本层并写入数据
  - 非写分配：直接将数据写入下一层

==对于程序员，建议心中采用写回和写分配模型==

4. 存储器山：描述程序时空局部性对读吞吐量的影响
   @import "6.41.jpg"

- 山脊：反应空间局部性影响，L2、L3、Mem 山脊存在空间局部性斜坡

## <center>第七章 链接 </center>

### 1. C 程序驱动

`c preprocessor(cpp) --> compiler(ccl) --> assembler(as) --> linker(ld) --> loader`
@import "7.2.jpg"

### 2. 静态链接
所有可重定位文件被链接成为一份可执行文件，该文件包含所有可重定位文件的信息
1. 步骤：
- 符号解析：将所有符号引用与唯一符号定义关联起来
- 重定位：将每个符号与唯一运行时内存地址关联起来

2. 可重定位目标文件（Linux Executable and Linkable Format）
@import "7.3.jpg"
- `.text`：代码
- `.rodata`：只读字符串，跳转表等
- `.data`：初始化的全局和静态C变量
- `.bss`：未初始化或初始化为0的全局和静态C变量，不占据空间
- `.symtab`：符号表，存放所有变量和函数的信息：
@import "7.4.jpg"
   `section`字段伪节：
    - `ABS`:不应该被重定位
    - `UNDEF`:未定义，在其他重定位文件定义，在本文件中引用
    - `COMMON`:未初始化的全局变量（区分于`.bss`:未初始化的静态变量和初始化为0的全局变量）
- `.rel.text`,`.rel.data`：存放重定位信息，即重定位条目(relocation entry)

3. 符号解析

- 符号：
    - 强符号：函数定义和初始化的全局变量
    - 弱符号：未初始化的全局变量
- 规则：
    - 多个同名强符号：链接错误
    - 同名强符号与弱符号：链接器选择强符号
    - 同名弱符号：链接器随意选择一个

## 附录：推荐阅读 
- CMU ICS 课程 https://www.bilibili.com/video/av31289365/
- MIT 课程 Missing Semester https://missing.csail.mit.edu
    - shell & shell script
    - vim
    - git
    - debugging
    - ...